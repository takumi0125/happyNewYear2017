!function(n){function e(o){if(t[o])return t[o].exports;var i=t[o]={exports:{},id:o,loaded:!1};return n[o].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var t={};return e.m=n,e.c=t,e.p="",e(0)}([function(n,e,t){n.exports=t(1)},function(n,e,t){var o;o=t(2),$(function(){return new o})},function(n,e,t){var o,i,r=function(n,e){return function(){return n.apply(e,arguments)}};window.utils=t(3),i=t(27),o=function(){function n(){this.windowResizeHanlder=r(this.windowResizeHanlder,this),this.mouseMoveHandler=r(this.mouseMoveHandler,this),this.deviceMotionHandler=r(this.deviceMotionHandler,this),this.update=r(this.update,this);var n,e,t;this.$window=$(window),this.$body=$("body"),n=$("#indicator"),t=new UAParser,e=t.getOS().name.toLowerCase(),"ios"!==e&&"android"!==e&&n.find(".txt").text("Please drag to rotate."),this.animationId=null,this.mainVisual=new i,Promise.all([this.mainVisual.init(),new Promise(function(n){return setTimeout(n,3e3)})]).then(function(n){return function(){return n.$window.on({resize:n.windowResizeHanlder,vrdisplaypresentchange:n.windowResizeHanlder}).trigger("resize"),n.update(),n.removeContents($("#loading"))}}(this)).then(function(e){return function(){var t;return n.on("click",function(o){return n.off("click"),clearTimeout(t),e.removeContents(n),!1}),t=setTimeout(function(){return clearTimeout(t),e.removeContents(n)},3e3)}}(this))}return n.prototype.removeContents=function(n){return new Promise(function(e){return function(e){n.addClass("hidden").on(utils.transitionend,function(t){n.remove(),e()})}}(this))},n.prototype.update=function(){this.animationId=requestAnimationFrame(this.update),this.mainVisual.draw()},n.prototype.deviceMotionHandler=function(n){},n.prototype.mouseMoveHandler=function(n){},n.prototype.windowResizeHanlder=function(n){null==n&&(n=null),this.mainVisual.resize(),3===this.mainVisual.manager.mode?this.$body.addClass("vr"):this.$body.removeClass("vr")},n}(),n.exports=o},function(n,e,t){n.exports={preloadImg:t(4),setUpBtnTwitter:t(5),setUpBtnLine:t(6),setUpBtnFacebook:t(7),transitionend:t(8),shuffleArr:t(9),map:t(10),capitalize:t(11),pad:t(12),isFirefox:t(13),isIE8:t(14),isIE9:t(15),isIE10:t(16),isIE11:t(17),isEdge:t(18),isiPad:t(19),isiPhone:t(20),isAndroid:t(21),getiOSVersion:t(22),getAndroidVersion:t(22)},t(23),t(24),t(25),t(26)},function(n,e){n.exports=function(n){return new Promise(function(e){var t;return t=new Image,t.addEventListener("load",function(n){return t.removeEventListener("load",arguments.callee),e()}),t.src=n})}},function(n,e){n.exports=function(n,e,t){var o;return null==t&&(t=""),o="https://twitter.com/intent/tweet?",o+=""===t?"text="+encodeURIComponent(e):"url="+encodeURIComponent(t)+"&text="+encodeURIComponent(e),n.on("click",function(n){n.preventDefault(),n.stopPropagation(),window.open(o,"twitterShare","width=670,height=400")})}},function(n,e){n.exports=function(n,e,t){var o;return null==t&&(t=""),o="http://line.me/msg/text/?",o+=""===t?""+encodeURIComponent(e):encodeURIComponent(e)+"\n"+encodeURIComponent(t),n.on("click",function(n){n.preventDefault(),n.stopPropagation(),window.open(o,"lineShare")})}},function(n,e){n.exports=function(n,e,t){var o;return null==t&&(t=""),o="https://www.facebook.com/sharer/sharer.php?&display=popup&u=",o+=""+encodeURIComponent(e),t&&(o+="&description="+encodeURIComponent(t)),n.on("click",function(n){n.preventDefault(),n.stopPropagation(),window.open(o,"facebookShare"+(new Date).getTime(),"width=670,height=400")})}},function(n,e){n.exports="transitionend webkitTransitionEnd mozTransitionEnd oTransitionEnd"},function(n,e){var t=[].indexOf||function(n){for(var e=0,t=this.length;e<t;e++)if(e in this&&this[e]===n)return e;return-1};n.exports=function(n){var e,o,i,r;for(r=[],o=i=n.length;i;)e=Math.floor(Math.random()*o),t.call(n,e)>=0&&(r.push(n[e]),delete n[e],i--);return r}},function(n,e){n.exports=function(n,e,t,o,i,r){var a;if(null==r&&(r=!0),r===!0){if(n<e)return o;if(n>t)return i}return a=(i-o)/(t-e),(n-e)*a+o}},function(n,e){n.exports=function(n){return n.charAt(0).toUpperCase()+n.slice(1)}},function(n,e){n.exports=function(n,e){var t,o,i;for(n=""+n,t=o=0,i=e;0<=i?o<i:o>i;t=0<=i?++o:--o)n="0"+n;return n.slice(-e)}},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("firefox")!==-1},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("msie 8.0")!==-1},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("msie 9.0")!==-1},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("msie 10.0")!==-1},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("rv:11.0")!==-1},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("edge")!==-1},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("ipad")!==-1},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("iphone")!==-1},function(n,e){n.exports=navigator.userAgent.toLowerCase().indexOf("android")!==-1},function(n,e){n.exports=function(){var n;return n=navigator.appVersion.match(/Android (\d+).(\d+).?(\d+)?;/),[parseInt(n[1],10),parseInt(n[2],10),parseInt(n[3]||0,10)]}},function(n,e){window.log=function(){return null!=window.console?null!=window.console.log.bind?window.console.log.bind(window.console):window.console.log:window.alert}()},function(n,e){window.requestAnimationFrame=function(n){return function(){return window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||function(n){return setTimeout(n,1e3/30)}}}(this)()},function(n,e){window.cancelAnimationFrame=function(n){return function(){return window.cancelAnimationFrame||window.mozCancelAnimationFrame||function(n){return clearTimeout(n)}}}(this)()},function(n,e){window.AudioContext=window.AudioContext||window.webkitAudioContext},function(n,e,t){var o,i,r,a,s,c,u=function(n,e){return function(){return n.apply(e,arguments)}};window.utils=t(3),a=t(28),r=t(32),i=t(35),c=t(38),o=t(48),s=function(){function n(n){this.parent=n,this.deviceMotionHandler=u(this.deviceMotionHandler,this),this.windowMouseMoveHandler=u(this.windowMouseMoveHandler,this),this.resize=u(this.resize,this),this.draw=u(this.draw,this),this.$container=$("#main"),this.isWebGLSupported=!1,this.sensorAxisDir=-1,(utils.isiPhone||utils.isiPad)&&(this.sensorAxisDir=1)}var e,t,s,x,l,m,v,p,d,h;return x=["Hello world!","I wish you all the best for this year!"],m="/assets/img/kingaShinnen.png",l="/assets/img/happyNewYear.png",h="/assets/img/year.png",s="/assets/img/clouds.png",e="/assets/img/arrow.png",p=3e3,d=1e3,v=400,t=new THREE.Vector2(0,-1),n.prototype.init=function(){var n,e,t,o,i,r,a;for(this.msgs=x,this.swMode=!1,i=location.search.replace("?","").split("&"),n=0,t=i.length;n<t;n++)o=i[n],r=o.split("="),e=r[0],a=r[1],"msg"===e&&""!==a&&(this.msgs=decodeURIComponent(a).split("\n"));return Detector.webgl?this.initWebGL():this.showNotSupported()},n.prototype.showNotSupported=function(){log("not supported"),alert("Sorry. Your Device is not supported.")},n.prototype.initWebGL=function(){var n;return this.width=this.$container.width(),this.height=this.$container.height(),this.$canvas=this.$container.find("canvas"),this.renderer=new THREE.WebGLRenderer({canvas:this.$canvas.get(0),antialias:!0}),this.renderer.setClearColor(16777215),null==this.renderer.extensions.get("OES_texture_float")&&null==this.renderer.extensions.get("OES_texture_half_float")&&this.showNotSupported(),n=Math.min(window.devicePixelRatio||1,2),this.renderer.setPixelRatio(n),this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(45,100,.1,1e3),this.cameraDefaultPos=this.camera.position.clone(),this.cameraMatrix=new THREE.Matrix4,this.controls=new THREE.VRControls(this.camera),this.effect=new THREE.VREffect(this.renderer),this.effect.setSize(this.width,this.height),this.manager=new WebVRManager(this.renderer,this.effect),new Promise(function(n){return function(n){return WebFont.load({custom:{families:["Sawarabi Mincho"]},active:function(){return log("fonts loaded"),n()},inactive:function(){return log("?")}})}}(this)).then(function(n){return function(){return n.isWebGLSupported=!0,n.init3DObjects()}}(this))},n.prototype.init3DObjects=function(n){var t,u;return t=new THREE.Vector4(1,1,1,1),this.kintaShinnen=new a(p),this.kintaShinnen.renderOrder=1,u=new THREE.Matrix4,this.kintaShinnen.setUniform("modelMatrixInverse",{type:"m4",value:u.getInverse(this.kintaShinnen.matrixWorld)}),this.year2017=new a(d),this.year2017.renderOrder=1,this.clouds=new i(v,s),this.clouds.renderOrder=2,this.clouds.setFog(.2,.8,this.camera.near,this.camera.far,t),this.floor=new r,this.floor.renderOrder=1,this.floor.setFog(.2,.8,this.camera.near,this.camera.far,t),this.message=new c(this.msgs),this.message.createRenderTexture(this.renderer,this.camera),this.arrows=new o(e),this.scene.add(this.floor),this.scene.add(this.kintaShinnen),this.scene.add(this.year2017),this.scene.add(this.clouds),this.scene.add(this.message),this.scene.add(this.arrows),Promise.all([this.kintaShinnen.init(m,Math.PI),this.kintaShinnen.loadTranslate2(l),this.year2017.init(h),this.year2017.loadTranslate2(h),this.clouds.init(),this.arrows.init()])},n.prototype.update3DObjects=function(){var n,e,o;e=this.camera.getWorldDirection(),o=new THREE.Vector2(e.x,e.z).normalize(),n=Math.acos(o.dot(t)),this.isShownMsgOnce||Math.abs(Math.PI-n)<.06&&(this.isShownMsgOnce=!0,this.showMsg()),this.kintaShinnen.update(e,n),this.year2017.update(e,n),this.floor.update(),this.clouds.update(),this.message.update(e),this.arrows.update()},n.prototype.showMsg=function(){log("show message"),this.kintaShinnen.transformTxt(1).then(function(n){return function(){return n.message.transform()}}(this))},n.prototype.draw=function(){this.update3DObjects(),this.controls.update(),this.manager.render(this.scene,this.camera)},n.prototype.resize=function(){this.isWebGLSupported&&(this.width=this.$container.width(),this.height=this.$container.height(),this.effect.setSize(this.width,this.height),this.renderer.setSize(this.width,this.height),this.renderer.setViewport(0,0,this.width,this.height),this.camera.aspect=this.width/this.height,this.camera.updateProjectionMatrix())},n.prototype.windowMouseMoveHandler=function(n){var e,t;e=utils.map(n.pageX/this.width,0,1,-1,1),t=utils.map(n.pageY/this.height,0,1,-1,1),this.setCameraPos(e,t)},n.prototype.deviceMotionHandler=function(n){var e,t;e=n.originalEvent.accelerationIncludingGravity.x/4,t=n.originalEvent.accelerationIncludingGravity.y/4,this.setCameraPos(e*this.sensorAxisDir,t*this.sensorAxisDir)},n.prototype.setCameraPos=function(n,e){var t;t=this.cameraDefaultPos.clone(),this.cameraMatrix.identity(),this.cameraMatrix.makeRotationX(e*Math.PI/6),t.applyMatrix4(this.cameraMatrix),this.cameraMatrix.makeRotationY(n*Math.PI/6),t.applyMatrix4(this.cameraMatrix),TweenMax.to(this.camera.position,3,{overwrite:!0,x:t.x,y:t.y,z:t.z,ease:Expo.easeOut,onUpdate:function(n){return function(){return n.camera.lookAt(new THREE.Vector3)}}(this)})},n}(),n.exports=s},function(n,e,t){var o,i,r=function(n,e){function t(){this.constructor=n}for(var o in e)a.call(e,o)&&(n[o]=e[o]);return t.prototype=e.prototype,n.prototype=new t,n.__super__=e.prototype,n},a={}.hasOwnProperty;o=t(29),i=function(n){function e(n){var i;this.numInstances=n,i=new THREE.SphereBufferGeometry(.8,4,2),this.geometry=new o(i,this.numInstances),this.material=new THREE.RawShaderMaterial({uniforms:{time:{type:"1f",value:0},eyeDir:{type:"3f",value:new THREE.Vector3},rotateY:{type:"float",value:0},cameraRotateY:{type:"float",value:0},animationParam1:{type:"float",value:1},animationParam2:{type:"float",value:0}},vertexShader:t(30),fragmentShader:t(31),transparent:!0}),e.__super__.constructor.call(this,this.geometry,this.material),i.dispose()}var i,a,s;return r(e,n),i=1/3,s=-300,a=60,e.prototype.transformTxt=function(n){return new Promise(function(e){return function(t){return TweenMax.to(e.material.uniforms.animationParam1,2,{value:0,ease:Linear.easeNone,delay:n,onComplete:function(){return t()}})}}(this))},e.prototype.init=function(n,e){return this.rotateY=null!=e?e:0,this.material.uniforms.rotateY.value=this.rotateY,this.createRandomValues(),this.loadImgData(n,"translate")},e.prototype.createRandomValues=function(){var n,e,t,o;for(t=[],n=e=0,o=this.numInstances;0<=o?e<o:e>o;n=0<=o?++e:--e)t.push({x:this.geometry.getRandomValue(),y:this.geometry.getRandomValue(),z:this.geometry.getRandomValue()});return this.geometry.addData("randomValues",t,3)},e.prototype.loadImgData=function(n,e,t){return null==t&&(t=0),new Promise(function(o){return function(r){var a,c,u;return u=$("<canvas>").get(0),c=u.getContext("2d"),a=$("<img>").one("load",function(n){var x,l,m,v,p,d,h,f,y,g,w,z,C,T;for(m=a.get(0),z=m.width,l=m.height,u.width=z,u.height=l,c.drawImage(m,0,0),v=c.getImageData(0,0,z,l).data,g=[],T=d=0,f=l;0<=f?d<f:d>f;T=0<=f?++d:--d)for(C=h=0,y=z;0<=y?h<y:h>y;C=0<=y?++h:--h)p=T*z+C,x=v[4*p+3],x>0&&(w=new THREE.Vector3((C-m.width/2)*i,(m.height/2-T)*i+t,s+Math.random()*s/30),w.applyAxisAngle(new THREE.Vector3(0,1,0),o.rotateY),g.push({x:w.x,y:w.y,z:w.z}));return g=_.shuffle(g),g.length=o.numInstances,o.geometry.addData(e,g,3),r()}).attr("src",n)}}(this))},e.prototype.loadTranslate2=function(n){return this.loadImgData(n,"translate2",a)},e.prototype.setUniform=function(n,e){this.material.uniforms[n]=e},e.prototype.update=function(n,e){this.material.uniforms.time.value+=.001,this.material.uniforms.eyeDir.value=n,this.material.uniforms.cameraRotateY.value=e},e}(THREE.Mesh),n.exports=i},function(n,e){var t,o=function(n,e){function t(){this.constructor=n}for(var o in e)i.call(e,o)&&(n[o]=e[o]);return t.prototype=e.prototype,n.prototype=new t,n.__super__=e.prototype,n},i={}.hasOwnProperty;t=function(n){function e(n,t){var o,i,r,a,s,c,u,x,l,m,v,p,d;for(this.numInstances=t,e.__super__.constructor.call(this),d=[],r=[],p=[],i=[],x=n.index.array.length,this.numPositions=n.attributes.position.array.length,o=s=0,l=this.numInstances;0<=l?s<l:s>l;o=0<=l?++s:--s){for(a=c=0,m=this.numPositions/3;0<=m?c<m:c>m;a=0<=m?++c:--c)d.push(n.attributes.position.array[3*a+0]),d.push(n.attributes.position.array[3*a+1]),d.push(n.attributes.position.array[3*a+2]),p.push(n.attributes.uv.array[2*a+0]),p.push(n.attributes.uv.array[2*a+1]),r.push(o);for(a=u=0,v=x;0<=v?u<v:u>v;a=0<=v?++u:--u)i.push(n.index.array[a]+this.numPositions/3*o)}this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(d),3)),this.addAttribute("uv",new THREE.BufferAttribute(new Float32Array(p),2)),this.addAttribute("instanceIndex",new THREE.BufferAttribute(new Float32Array(r),1)),this.setIndex(new THREE.BufferAttribute(new Uint16Array(i),1)),this.computeVertexNormals()}return o(e,n),e.prototype.addData=function(n,e,t){var o,i,r,a,s,c,u,x,l,m,v,p,d,h,f,y;if(i=[],1===t)for(r=s=0,v=this.numInstances;0<=v?s<v:s>v;r=0<=v?++s:--s)for(a=c=0,p=this.numPositions/3;0<=p?c<p:c>p;a=0<=p?++c:--c)i.push(e[r]);else if(2===t)for(r=u=0,d=this.numInstances;0<=d?u<d:u>d;r=0<=d?++u:--u)for(o=e[r],a=x=0,h=this.numPositions/3;0<=h?x<h:x>h;a=0<=h?++x:--x)i.push(o.x),i.push(o.y);else if(3===t)for(r=l=0,f=this.numInstances;0<=f?l<f:l>f;r=0<=f?++l:--l)for(o=e[r],a=m=0,y=this.numPositions/3;0<=y?m<y:m>y;a=0<=y?++m:--m)i.push(o.x),i.push(o.y),i.push(o.z);this.addAttribute(n,new THREE.BufferAttribute(new Float32Array(i),t)),this.computeVertexNormals()},e.prototype.getRandomValue=function(){return(Math.random()+Math.random()+Math.random()+Math.random()+Math.random())/5},e}(THREE.BufferGeometry),n.exports=t},function(n,e){n.exports="#define GLSLIFY 1\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\n\nuniform float f;\nuniform float time;\nuniform vec3 cameraPosition;\nuniform vec3 eyeDir;\nuniform float rotateY;\nuniform float cameraRotateY;\nuniform float animationParam1;\nuniform float animationParam2;\n\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 translate;\nattribute vec3 translate2;\nattribute vec3 normal;\nattribute vec3 randomValues;\n\nvarying vec4 vColor;\n\nconst float PI_1_0 = 3.1415926535897932384626433832795;\n\n\nvec3 rotateVec3_2_1(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n    a.x * a.x * r + c,\n    a.y * a.x * r + a.z * s,\n    a.z * a.x * r - a.y * s,\n    a.x * a.y * r - a.z * s,\n    a.y * a.y * r + c,\n    a.z * a.y * r + a.x * s,\n    a.x * a.z * r + a.y * s,\n    a.y * a.z * r - a.x * s,\n    a.z * a.z * r + c\n  );\n  return m * p;\n}\n\n\nfloat map_3_2(float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp) {\n  if(clamp == true) {\n    if(value < inputMin) return outputMin;\n    if(value > inputMax) return outputMax;\n  }\n\n  float p = (outputMax - outputMin) / (inputMax - inputMin);\n  return ((value - inputMin) * p) + outputMin;\n}\n\n\nvec3 hsv2rgb_4_3(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat exponentialInOut_7_4(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\n\n#ifndef PI\n#define PI 3.141592653589793\n#endif\n\nfloat sineInOut_8_5(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_5_6(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_5_6(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_5_7(vec3 x) {\n  return mod289_5_6(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_5_8(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_5_6(i); // Avoid truncation effects in permutation\n  vec3 p = permute_5_7( permute_5_7( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_6_9(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_6_9(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_6_10(vec4 x) {\n     return mod289_6_9(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_6_11(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_6_12(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_6_13 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_6_14 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_6_14;\n  vec3 i1 = min( g_6_14.xyz, l.zxy );\n  vec3 i2 = max( g_6_14.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_6_13.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_6_9(i);\n  vec4 p = permute_6_10( permute_6_10( permute_6_10(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_6_13.wyz - D_6_13.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_6_15 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_6_16 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_6_15.xy,h.z);\n  vec3 p3 = vec3(a1_6_15.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_6_11(vec4(dot(p0_6_16,p0_6_16), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_6_16 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_6_16,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nconst vec4 ambientColor = vec4(0.1, 0.1, 0.1, 0.0);\nconst vec3 lightPos = vec3(0.0, -100.0, 0.0);\n\nconst vec3 axisX = vec3(1.0, 0.0, 0.0);\nconst vec3 axisY = vec3(0.0, 1.0, 0.0);\nconst vec3 axisZ = vec3(0.0, 0.0, 1.0);\n\nfloat getRad(float scale, float offset) {\n  return map_3_2(mod(time * scale + offset, PI_1_0 * 2.0), 0.0, PI_1_0 * 2.0, -PI_1_0, PI_1_0, true);\n}\n\nfloat getAnimationParam(float value, float randomValue) {\n  float r = randomValue * 0.2;\n  return map_3_2(value, r, r + 0.8, 0.0, 1.0, true);\n}\n\nvoid main() {\n  vec3 pos = position;\n  vec3 n = normal;\n  float theta;\n\n  float r = snoise_6_12(translate / 10.0);\n  float scale = (sin(getRad(20.0, r * 60.0)) + 1.0) + 1.0;\n  pos *= scale;\n\n  theta = getRad(10.0, r * 120.0);\n  pos = rotateVec3_2_1(pos, theta, axisX);\n  n   = rotateVec3_2_1(n,   theta, axisX);\n  pos = rotateVec3_2_1(pos, theta, axisY);\n  n   = rotateVec3_2_1(n,   theta, axisY);\n  pos = rotateVec3_2_1(pos, theta, axisZ);\n  n   = rotateVec3_2_1(n,   theta, axisZ);\n\n  // 文字\n  float p = exponentialInOut_7_4(getAnimationParam(animationParam1, snoise_6_12(translate2)));\n  pos += (translate * p + translate2 * (1.0 - p));\n\n  // ランダム\n  p = sineInOut_8_5(abs(abs(cameraRotateY) - rotateY) / PI_1_0);\n  theta = getRad(0.1, r * 120.0);\n  pos.x += p * sin(theta) * 700.0;\n\n  theta = getRad(0.1 * p, snoise_5_8(randomValues.xy * 100.0) * 10.0 * p);\n  pos = rotateVec3_2_1(pos, theta, axisZ);\n  n   = rotateVec3_2_1(n,   theta, axisZ);\n\n  theta = getRad(0.1 * p, snoise_5_8(randomValues.yz * 100.0) * 10.0 * p);\n  pos = rotateVec3_2_1(pos, theta, axisX);\n  n   = rotateVec3_2_1(n,   theta, axisX);\n\n  theta = getRad(0.1 * p, snoise_5_8(randomValues.zx * 100.0) * 10.0 * p);\n  pos = rotateVec3_2_1(pos, theta, axisY);\n  n   = rotateVec3_2_1(n,   theta, axisY);\n\n\n  vec4 modelPos = modelMatrix * vec4(pos, 1.0);\n\n  vec3 light = normalize(lightPos - modelPos.xyz);\n  vec3 eye = normalize(eyeDir).xyz;\n  float diffuse = clamp(dot(n, light), 0.0, 1.0) + 0.2;\n\n  gl_Position = projectionMatrix * viewMatrix * modelPos;\n  vColor = vec4(1.0, 0.6, 0.0, 1.0) * vec4(vec3(diffuse), 1.0) + ambientColor;\n}\n"},function(n,e){n.exports="precision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vColor;\n}\n"},function(n,e,t){var o,i=function(n,e){function t(){this.constructor=n}for(var o in e)r.call(e,o)&&(n[o]=e[o]);return t.prototype=e.prototype,n.prototype=new t,n.__super__=e.prototype,n},r={}.hasOwnProperty;o=function(n){function e(){this.geometry=new THREE.PlaneGeometry(2e3,2e3,50,50),this.geometry.rotateX(-Math.PI/2),this.material=new THREE.RawShaderMaterial({uniforms:{time:{type:"1f",value:0},fogStart:{type:"1f",value:0},fogEnd:{type:"1f",value:0},near:{type:"1f",value:0},far:{type:"1f",value:0},fogColor:{type:"4f",value:new THREE.Vector4(1,1,1,1)}},vertexShader:t(33),fragmentShader:t(34),transparent:!0}),e.__super__.constructor.call(this,this.geometry,this.material),this.position.y-=200}return i(e,n),e.prototype.setFog=function(n,e,t,o,i){this.material.uniforms.fogStart.value=n,this.material.uniforms.fogEnd.value=e,this.material.uniforms.near.value=t,this.material.uniforms.far.value=o,this.material.uniforms.fogColor.value=i},e.prototype.update=function(){this.material.uniforms.time.value+=.001},e}(THREE.Mesh),n.exports=o},function(n,e){n.exports="#define GLSLIFY 1\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 cameraPosition;\nuniform float time;\nuniform float fogStart;\nuniform float fogEnd;\nuniform float near;\nuniform float far;\n\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec2 normal;\n\nvarying vec4 vColor;\nvarying float vFogFactor;\n\nconst float PI_1_0 = 3.1415926535897932384626433832795;\n\n\nvec3 rotateVec3_2_1(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n    a.x * a.x * r + c,\n    a.y * a.x * r + a.z * s,\n    a.z * a.x * r - a.y * s,\n    a.x * a.y * r - a.z * s,\n    a.y * a.y * r + c,\n    a.z * a.y * r + a.x * s,\n    a.x * a.z * r + a.y * s,\n    a.y * a.z * r - a.x * s,\n    a.z * a.z * r + c\n  );\n  return m * p;\n}\n\n\nfloat map_3_2(float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp) {\n  if(clamp == true) {\n    if(value < inputMin) return outputMin;\n    if(value > inputMax) return outputMax;\n  }\n\n  float p = (outputMax - outputMin) / (inputMax - inputMin);\n  return ((value - inputMin) * p) + outputMin;\n}\n\n\nvec3 hsv2rgb_4_3(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_5_4(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_5_4(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_5_5(vec3 x) {\n  return mod289_5_4(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_5_6(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_5_4(i); // Avoid truncation effects in permutation\n  vec3 p = permute_5_5( permute_5_5( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_6_7(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_6_7(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_6_8(vec4 x) {\n     return mod289_6_7(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_6_9(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_6_10(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_6_11 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_6_12 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_6_12;\n  vec3 i1 = min( g_6_12.xyz, l.zxy );\n  vec3 i2 = max( g_6_12.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_6_11.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_6_7(i);\n  vec4 p = permute_6_8( permute_6_8( permute_6_8(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_6_11.wyz - D_6_11.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_6_13 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_6_14 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_6_13.xy,h.z);\n  vec3 p3 = vec3(a1_6_13.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_6_9(vec4(dot(p0_6_14,p0_6_14), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_6_14 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_6_14,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nfloat getRad(float scale, float offset) {\n  return map_3_2(mod(time * scale + offset, PI_1_0 * 2.0), 0.0, PI_1_0 * 2.0, -PI_1_0, PI_1_0, true);\n}\n\nvoid main() {\n  vec3 pos = position;\n\n  pos.y = 2.0 * sin(getRad(20.0, snoise_5_6(position.xz * 100.0) * 10.0));\n\n  vec4 modelPos = modelMatrix * vec4(pos, 1.0);\n\n  // fog\n  float linerPos = length(modelPos.xyz - cameraPosition) / (far - near);\n  vFogFactor = clamp((fogEnd - linerPos) / (fogEnd - fogStart), 0.0, 1.0);\n\n  // color\n  vColor = vec4(\n    hsv2rgb_4_3(vec3(\n      map_3_2(sin(getRad(20.0, snoise_5_6(position.xz * 100.0) * 10.0)), -1.0, 1.0, 0.1, 0.15, true),\n      0.3,\n      1.0\n    )),\n    1.0\n  );\n\n  // position\n  gl_Position = projectionMatrix * viewMatrix * modelPos;\n}\n";
},function(n,e){n.exports="precision mediump float;\n#define GLSLIFY 1\n\nuniform vec4 fogColor;\n\nvarying vec4 vColor;\nvarying float vFogFactor;\n\nvoid main(){\n  vec4 fragColor = mix(fogColor, vColor, vFogFactor);\n  gl_FragColor = fragColor;\n}\n"},function(n,e,t){var o,i,r=function(n,e){function t(){this.constructor=n}for(var o in e)a.call(e,o)&&(n[o]=e[o]);return t.prototype=e.prototype,n.prototype=new t,n.__super__=e.prototype,n},a={}.hasOwnProperty;i=t(29),o=function(n){function e(n,o){var r;this.numClouds=n,this.imgPath=o,r=new THREE.PlaneBufferGeometry(100,100),this.geometry=new i(r,this.numClouds),this.material=new THREE.RawShaderMaterial({uniforms:{time:{type:"1f",value:0},fogStart:{type:"1f",value:0},fogEnd:{type:"1f",value:0},near:{type:"1f",value:0},far:{type:"1f",value:0},texture:{type:"t"},fogColor:{type:"4f",value:new THREE.Vector4(1,1,1,1)}},vertexShader:t(36),fragmentShader:t(37),transparent:!0,depthWrite:!1,depthTest:!1}),e.__super__.constructor.call(this,this.geometry,this.material),this.position.y-=150}return r(e,n),e.prototype.init=function(){var n,e,t,o,i;for(n=[],e=t=0,o=this.numClouds;0<=o?t<o:t>o;e=0<=o?++t:--t)i=new THREE.Vector3(800*Math.random(),utils.map(Math.random(),0,1,-10,10),0),i.applyAxisAngle(new THREE.Vector3(0,1,0),2*Math.random()*Math.PI),n.push({x:i.x,y:i.y,z:i.z});return this.geometry.addData("translate",n,3),this.frustumCulled=!1,new Promise(function(n){return function(e){return(new THREE.TextureLoader).load(n.imgPath,function(t){return t.flipY=!1,t.needUpdate=!0,n.material.uniforms.texture.value=t,e()})}}(this))},e.prototype.setFog=function(n,e,t,o,i){this.material.uniforms.fogStart.value=n,this.material.uniforms.fogEnd.value=e,this.material.uniforms.near.value=t,this.material.uniforms.far.value=o,this.material.uniforms.fogColor.value=i},e.prototype.update=function(){this.material.uniforms.time.value+=.001},e}(THREE.Mesh),n.exports=o},function(n,e){n.exports="#define GLSLIFY 1\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 cameraPosition;\nuniform float time;\nuniform float fogStart;\nuniform float fogEnd;\nuniform float near;\nuniform float far;\n\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 translate;\nattribute float instanceIndex;\n\nvarying vec4 vColor;\nvarying float vFogFactor;\nvarying vec2 vUv;\n\nconst float PI_1_0 = 3.1415926535897932384626433832795;\n\n\nvec3 rotateVec3_2_1(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n    a.x * a.x * r + c,\n    a.y * a.x * r + a.z * s,\n    a.z * a.x * r - a.y * s,\n    a.x * a.y * r - a.z * s,\n    a.y * a.y * r + c,\n    a.z * a.y * r + a.x * s,\n    a.x * a.z * r + a.y * s,\n    a.y * a.z * r - a.x * s,\n    a.z * a.z * r + c\n  );\n  return m * p;\n}\n\n\nfloat map_3_2(float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp) {\n  if(clamp == true) {\n    if(value < inputMin) return outputMin;\n    if(value > inputMax) return outputMax;\n  }\n\n  float p = (outputMax - outputMin) / (inputMax - inputMin);\n  return ((value - inputMin) * p) + outputMin;\n}\n\n\nvec3 hsv2rgb_4_3(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_5_4(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_5_4(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_5_5(vec3 x) {\n  return mod289_5_4(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_5_6(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_5_4(i); // Avoid truncation effects in permutation\n  vec3 p = permute_5_5( permute_5_5( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_6_7(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_6_7(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_6_8(vec4 x) {\n     return mod289_6_7(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_6_9(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_6_10(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_6_11 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_6_12 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_6_12;\n  vec3 i1 = min( g_6_12.xyz, l.zxy );\n  vec3 i2 = max( g_6_12.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_6_11.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_6_7(i);\n  vec4 p = permute_6_8( permute_6_8( permute_6_8(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_6_11.wyz - D_6_11.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_6_13 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_6_14 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_6_13.xy,h.z);\n  vec3 p3 = vec3(a1_6_13.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_6_9(vec4(dot(p0_6_14,p0_6_14), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_6_14 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_6_14,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nfloat getRad(float scale, float offset) {\n  return map_3_2(mod(time * scale + offset, PI_1_0 * 2.0), 0.0, PI_1_0 * 2.0, -PI_1_0, PI_1_0, true);\n}\n\nvoid main() {\n  vec3 pos = translate;\n  float n = map_3_2(snoise_5_6(translate.xz * 10.0), 0.0, 1.0, -1.0, 1.0, true);\n  pos = rotateVec3_2_1(pos, getRad(0.4 * n, n * 100.0), vec3(0.0, 1.0, 0.0));\n\n  vec4 modelPos = modelMatrix * vec4(pos, 1.0);\n\n  // fog\n  float linerPos = length(modelPos.xyz - cameraPosition) / (far - near);\n  vFogFactor = clamp((fogEnd - linerPos) / (fogEnd - fogStart), 0.0, 1.0);\n\n  // color\n  vColor = vec4(\n    hsv2rgb_4_3(vec3(\n      map_3_2(sin(getRad(10.0, snoise_5_6(translate.xz * 100.0) * 10.0)), -1.0, 1.0, 0.1, 0.15, true),\n      0.8,\n      1.0\n    )),\n    1.0\n  );\n\n  // uv\n  float index = mod(instanceIndex, 10.0);\n  float colIndex = mod(index, 5.0);\n  float rowIndex = floor(index / 5.0);\n  vUv = vec2(\n    (uv.x + colIndex) / 5.0,\n    (uv.y + rowIndex) / 2.0\n  );\n\n  // position\n  vec4 modelViewPos = viewMatrix * modelPos;\n  modelViewPos += vec4(position, 1.0);\n  gl_Position = projectionMatrix * modelViewPos;\n}\n"},function(n,e){n.exports="precision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 vColor;\nvarying vec2 vUv;\nvarying float vFogFactor;\n\nuniform vec4 fogColor;\nuniform sampler2D texture;\n\nvoid main(){\n  vec4 color = vColor * texture2D(texture, vUv);\n  if(color.a == 0.0) {\n    discard;\n  } else {\n    color.a *= 0.6;\n    gl_FragColor = mix(vec4(fogColor.r, fogColor.g, fogColor.b, color.a), color, vFogFactor);\n  }\n  // gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n"},function(n,e,t){var o,i,r,a=function(n,e){function t(){this.constructor=n}for(var o in e)s.call(e,o)&&(n[o]=e[o]);return t.prototype=e.prototype,n.prototype=new t,n.__super__=e.prototype,n},s={}.hasOwnProperty;o=t(29),r=t(39),i=function(n){function e(n){var i,r,a,s,c,u,x,l,m,v,p,d,h,f,y,_,g,w,z,C;for(this.msgs=n,this.geometry=new THREE.BufferGeometry,this.currentTime=(new Date).getTime(),this.vertices=[],this.translates=[],this.instanceIndices=[],this.lineIndices=[],this.uvs=[],this.randomValues=[],this.indices=[],this.numPushedIndices=0,this.numMsgs=this.msgs.length,this.numInstances=0,this.animationParam1=1,this.seperationDistance=30,this.alignmentDistance=40,this.cohesionDistance=40,a=$("<canvas>").get(0),r=a.getContext("2d"),v=1.4,h=v*o,s="Sawarabi Mincho",c="normal "+o+"px/"+v+"em georgia, '"+s+"', serif",i="#fff",r.fillStyle=i,r.font=c,d=0,y=[],w=this.msgs,u=x=0,l=w.length;x<l;u=++x)p=w[u],f=r.measureText(p).width,y.push(f),d=Math.max(f,d);for(a.width=d,a.height=this.numMsgs*h,r.clearRect(0,0,a.width,a.height),r.fillStyle=i,r.font=c,z=this.msgs,u=g=0,m=z.length;g<m;u=++g)p=z[u],r.fillText(p,0,u*h+.7*h),this.addMsgLineGeometries(u,d,y[u],h);this.geometry.addAttribute("position",new THREE.BufferAttribute(new Float32Array(this.vertices),3)),this.geometry.addAttribute("translate",new THREE.BufferAttribute(new Float32Array(this.translates),3)),this.geometry.addAttribute("uv",new THREE.BufferAttribute(new Float32Array(this.uvs),2)),this.geometry.addAttribute("instanceIndex",new THREE.BufferAttribute(new Float32Array(this.instanceIndices),1)),this.geometry.addAttribute("lineIndex",new THREE.BufferAttribute(new Float32Array(this.lineIndices),1)),this.geometry.addAttribute("randomValues",new THREE.BufferAttribute(new Float32Array(this.randomValues),3)),this.geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(this.indices),1)),_=this.instanceIndices.length,delete this.vertices,delete this.translates,delete this.uvs,delete this.instanceIndices,delete this.lineIndices,delete this.randomValues,delete this.indices,this.geometry.computeVertexNormals(),C=new THREE.Texture(a),C.flipY=!1,C.needsUpdate=!0,this.material=new THREE.RawShaderMaterial({uniforms:{time:{type:"1f",value:0},numInstances:{type:"1f",value:this.numInstances},animationParam1:{type:"1f",value:this.animationParam1},txtTexture:{type:"t",value:C},velocityTexture:{type:"t",value:null},posTexture:{type:"t",value:null},renderTextureResolution:{type:"2f",value:new THREE.Vector2}},vertexShader:t(40),fragmentShader:t(41),transparent:!0,side:THREE.DoubleSide}),e.__super__.constructor.call(this,this.geometry,this.material),this.frustumCulled=!1,log("instances",this.numInstances),log("textureColSize",this.getTextureColSize())}var o,i,s,c,u;return a(e,n),i=10,c=-300,s=-30,u=.25,o=60,e.prototype.initDatGUI=function(){var n,e,t,o,i;i=new dat.GUI,n=i.add(this,"animationParam1",0,1),n.onChange(function(n){return function(e){return n.material.uniforms.animationParam1.value=e}}(this)),e=i.add(this,"seperationDistance",0,100),t=i.add(this,"alignmentDistance",0,100),o=i.add(this,"cohesionDistance",0,100),e.onChange(function(n){return function(e){return n.updateParams(n.seperationDistance,n.alignmentDistance,n.cohesionDistance)}}(this)),t.onChange(function(n){return function(e){return n.updateParams(n.seperationDistance,n.alignmentDistance,n.cohesionDistance)}}(this)),o.onChange(function(n){return function(e){return n.updateParams(n.seperationDistance,n.alignmentDistance,n.cohesionDistance)}}(this))},e.prototype.createRenderTexture=function(n,e){var o;o=this.getTextureColSize(),this.material.uniforms.renderTextureResolution.value.x=o,this.material.uniforms.renderTextureResolution.value.y=o,this.velocityTexture=new r(o,o,n,e,t(42),t(43),t(44),t(45)),this.velocityTexture.initOtherTexture("posTexture"),this.velocityTexture.initUniforms({delta:{type:"1f",value:0},seperationDistance:{type:"1f",value:this.seperationDistance},alignmentDistance:{type:"1f",value:this.alignmentDistance},cohesionDistance:{type:"1f",value:this.cohesionDistance},numInstances:{type:"1f",value:this.numInstances},eyeDir:{type:"3f",value:new THREE.Vector3}}),this.posTexture=new r(o,o,n,e,t(42),t(46),t(44),t(47)),this.posTexture.initOtherTexture("velocityTexture"),this.posTexture.initUniforms({delta:{type:"1f",value:0}}),this.updateParams(this.seperationDistance,this.alignmentDistance,this.cohesionDistance)},e.prototype.updateParams=function(n,e,t){this.velocityTexture.updateUniform("seperationDistance",n),this.velocityTexture.updateUniform("alignmentDistance",e),this.velocityTexture.updateUniform("cohesionDistance",t)},e.prototype.alignPow2=function(n){var e;for(e=1;n>(e<<=1)&&e;);return e},e.prototype.getTextureColSize=function(){var n;return n=Math.ceil(Math.sqrt(this.numInstances)),n=this.alignPow2(n)},e.prototype.getRandomValue=function(){return(Math.random()+Math.random()+Math.random()+Math.random()+Math.random())/5},e.prototype.addMsgLineGeometries=function(n,e,t,o){var r,a,x,l,m,v,p,d,h,f,y,_,g,w,z,C,T,M,b,I,E,P,D,A,R,S,L;for(a=o/i,d=Math.floor(t/a),x=t/d,r=new THREE.PlaneBufferGeometry(x,a),h=r.index.array.length,f=r.attributes.position.array.length,l=p=0,T=i;0<=T?p<T:p>T;l=0<=T?++p:--p)for(_=(-t+x)/2,g=-a/2-a*l-a*i*n,m=y=0,M=d;0<=M?y<M:y>M;m=0<=M?++y:--y){for(C=[this.getRandomValue(),this.getRandomValue(),this.getRandomValue()],E=new THREE.Vector3((_+m*x)*u,g*u+s,c),v=w=0,b=f/3;0<=b?w<b:w>b;v=0<=b?++w:--w)L=new THREE.Vector3(r.attributes.position.array[3*v+0],r.attributes.position.array[3*v+1],r.attributes.position.array[3*v+2]),L.multiplyScalar(u),P=L.clone(),P.add(E),P.sub(L),this.vertices.push(L.x),this.vertices.push(L.y),this.vertices.push(L.z),this.translates.push(P.x),this.translates.push(P.y),this.translates.push(P.z),this.randomValues.push(C[0]),this.randomValues.push(C[1]),this.randomValues.push(C[2]),D=1/d*t/e,S=1/this.numMsgs,R=S/i,this.uvs.push((r.attributes.uv.array[2*v+0]+m)*D),A=r.attributes.uv.array[2*v+1],this.uvs.push(1-(A*R+(this.numMsgs-n-1)*S+(i-l)*R)),this.instanceIndices.push(this.numInstances),this.lineIndices.push(l);for(v=z=0,I=h;0<=I?z<I:z>I;v=0<=I?++z:--z)this.indices.push(r.index.array[v]+f/3*(l*d+m)+this.numPushedIndices);this.numInstances++}this.numPushedIndices+=f/3*d*i,r.dispose()},e.prototype.transform=function(n){return new Promise(function(e){return function(t){return TweenMax.to(e.material.uniforms.animationParam1,4,{value:0,ease:Linear.easeNone,delay:n,onComplete:function(){return t()}})}}(this))},e.prototype.update=function(n){var e,t;e=(new Date).getTime(),t=(e-this.currentTime)/1e3,this.currentTime=e,this.velocityTexture.updateUniform("eyeDir",n),this.velocityTexture.updateUniform("delta",t),this.velocityTexture.updateOtherTexture("posTexture",this.posTexture.getTexture()),this.velocityTexture.update(),this.posTexture.updateUniform("delta",t),this.posTexture.updateOtherTexture("velocityTexture",this.velocityTexture.getTexture()),this.posTexture.update(),this.material.uniforms.time.value+=.001,this.material.uniforms.posTexture.value=this.posTexture.getTexture(),this.material.uniforms.velocityTexture.value=this.velocityTexture.getTexture()},e}(THREE.Mesh),n.exports=i},function(n,e){var t;t=function(){function n(n,e,t,o,i,r,a,s){var c,u;this.width=n,this.height=e,this.renderer=t,this.camera=o,this.currentTextureIndex=0,this.renderTargets=[new THREE.WebGLRenderTarget(this.width,this.height,{magFilter:THREE.NearestFilter,minFilter:THREE.NearestFilter,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,format:THREE.RGBAFormat,type:/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?THREE.HalfFloatType:THREE.FloatType,stencilBuffer:!1})],this.renderTargets[1]=this.renderTargets[0].clone(),c=new THREE.RawShaderMaterial({vertexShader:i,fragmentShader:r}),u=new THREE.Mesh(new THREE.PlaneGeometry(1e4,1e4),c),this.scene=new THREE.Scene,this.scene.add(u),this.renderer.render(this.scene,this.camera,this.renderTargets[0]),this.renderer.render(this.scene,this.camera,this.renderTargets[1]),c.dispose(),c=null,this.updateMaterial=new THREE.RawShaderMaterial({uniforms:{texture:{type:"t",value:this.getTexture()},time:{type:"1f",value:0}},vertexShader:a,fragmentShader:s}),this.updateMaterial.defines.resolution="vec2("+this.width.toFixed(1)+", "+this.height.toFixed(1)+")",u.material=this.updateMaterial,this.renderTargets[0].texture.flipY=!1,this.renderTargets[1].texture.flipY=!1}return n.prototype.initOtherTexture=function(n,e){this.updateMaterial.uniforms[n]={type:"t",value:null}},n.prototype.updateOtherTexture=function(n,e){this.updateMaterial.uniforms[n].value=e},n.prototype.setDefine=function(n,e){this.updateMaterial.defines[n]=e},n.prototype.initUniforms=function(n){var e,t;for(e in n)t=n[e],this.updateMaterial.uniforms[e]=t},n.prototype.updateUniform=function(n,e){this.updateMaterial.uniforms[n].value=e},n.prototype.update=function(){this.updateMaterial.uniforms.texture.value=this.getTexture(),this.updateMaterial.uniforms.time.value+=.001,this.flipTexture(),this.renderer.render(this.scene,this.camera,this.renderTargets[this.currentTextureIndex])},n.prototype.flipTexture=function(){this.currentTextureIndex=(this.currentTextureIndex+1)%2},n.prototype.getTexture=function(){return this.renderTargets[this.currentTextureIndex].texture},n}(),n.exports=t},function(n,e){n.exports="#define GLSLIFY 1\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 normalMatrix;\n\nuniform float time;\nuniform float animationParam1;\nuniform float numInstances;\nuniform vec2 renderTextureResolution;\n\nuniform sampler2D posTexture;\nuniform sampler2D velocityTexture;\n\nattribute vec3 position;\nattribute vec3 translate;\nattribute vec2 uv;\nattribute vec3 normal;\nattribute vec3 randomValues;\nattribute float lineIndex;\nattribute float instanceIndex;\n\nvarying vec2 vUv;\nvarying float vColorParam;\nvarying vec4 vLineColor;\n\nconst float PI_1_0 = 3.1415926535897932384626433832795;\n\n\nvec3 rotateVec3_2_1(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n    a.x * a.x * r + c,\n    a.y * a.x * r + a.z * s,\n    a.z * a.x * r - a.y * s,\n    a.x * a.y * r - a.z * s,\n    a.y * a.y * r + c,\n    a.z * a.y * r + a.x * s,\n    a.x * a.z * r + a.y * s,\n    a.y * a.z * r - a.x * s,\n    a.z * a.z * r + c\n  );\n  return m * p;\n}\n\n\nfloat map_3_2(float value, float inputMin, float inputMax, float outputMin, float outputMax, bool clamp) {\n  if(clamp == true) {\n    if(value < inputMin) return outputMin;\n    if(value > inputMax) return outputMax;\n  }\n\n  float p = (outputMax - outputMin) / (inputMax - inputMin);\n  return ((value - inputMin) * p) + outputMin;\n}\n\n\nvec3 hsv2rgb_4_3(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat exponentialInOut_5_4(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_6_5(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_6_5(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_6_6(vec4 x) {\n     return mod289_6_5(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_6_7(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_6_8(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_6_9 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_6_10 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_6_10;\n  vec3 i1 = min( g_6_10.xyz, l.zxy );\n  vec3 i2 = max( g_6_10.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_6_9.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_6_5(i);\n  vec4 p = permute_6_6( permute_6_6( permute_6_6(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_6_9.wyz - D_6_9.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_6_11 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_6_12 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_6_11.xy,h.z);\n  vec3 p3 = vec3(a1_6_11.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_6_7(vec4(dot(p0_6_12,p0_6_12), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_6_12 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_6_12,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nconst vec3 axisX = vec3(1.0, 0.0, 0.0);\nconst vec3 axisY = vec3(0.0, 1.0, 0.0);\nconst vec3 axisZ = vec3(0.0, 0.0, 1.0);\n\nfloat getRad(float scale, float offset) {\n  return map_3_2(mod(time * scale + offset, PI_1_0 * 2.0), 0.0, PI_1_0 * 2.0, -PI_1_0, PI_1_0, true);\n}\n\nfloat getAnimationParam(float value, float randomValue) {\n  float r = randomValue * 0.4;\n  return map_3_2(value, r, r + 0.6, 0.0, 1.0, true);\n}\n\nvoid main() {\n  vec3 pos = position;\n\n  // boids animation\n  float p = exponentialInOut_5_4(getAnimationParam(animationParam1, 1.0 - instanceIndex / numInstances));\n  vec2 tuv = vec2(\n    mod(instanceIndex, renderTextureResolution.x),\n    floor(instanceIndex / renderTextureResolution.x)\n  ) / renderTextureResolution;\n\n  // shape\n  pos.x *= (1.0 - p * 0.8);\n  pos.y *= (1.0 + p * 4.0);\n\n  // attitude\n  pos = rotateVec3_2_1(pos, p * PI_1_0 * 1.5, axisX);\n  pos = rotateVec3_2_1(pos, p * sin(getRad(10.0, randomValues.x * 10.0)), axisZ);\n  vec3 v = normalize(texture2D(velocityTexture, tuv).xyz);\n  float angle = acos(dot(-axisZ, v));\n  pos = rotateVec3_2_1(pos, angle * p, normalize(cross(-axisZ, v)));\n  pos += p * texture2D(posTexture, tuv).xyz;\n\n  // txt position\n  pos += translate * (1.0 - p);\n  pos = rotateVec3_2_1(pos, PI_1_0, axisY);\n  vec4 modelPos = modelMatrix * vec4(pos, 1.0);\n  gl_Position = projectionMatrix * viewMatrix * modelPos;\n  vec3 posN = normalize(modelPos.xyz);\n\n  vUv = uv;\n  vColorParam = p;\n  vLineColor = vec4(hsv2rgb_4_3(vec3(\n    map_3_2(sin(getRad(10.0, snoise_6_8(posN + randomValues / 3.0) * 30.0)), -1.0, 1.0, 0.1, 0.15, true),\n    map_3_2(sin(getRad(50.0, snoise_6_8(posN + randomValues) * 30.0)), -1.0, 1.0, 0.0, 1.0, true),\n    1.0\n  )), 0.8);\n}\n"},function(n,e){n.exports="precision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying float vColorParam;\nvarying vec4 vLineColor;\n\nuniform sampler2D txtTexture;\n\n// const vec4 lineColor = vec4(1.0, 0.6, 0.0, 0.8);\nconst vec4 lineColor = vec4(0.8, 0.8, 0.8, 0.4);\nconst vec4 txtColor = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid main(){\n  vec4 texColor = texture2D(txtTexture, vUv);\n  vec4 color = mix(texColor * txtColor, vLineColor, vColorParam);\n  if(color.a == 0.0) {\n    discard;\n  } else {\n    gl_FragColor = color;\n  }\n}\n"},function(n,e){n.exports="#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n"},function(n,e){n.exports="precision highp float;\n#define GLSLIFY 1\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_1_0(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_1_1(vec3 x) {\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_1_2(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_1_0(i); // Avoid truncation effects in permutation\n  vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\n\nvoid main(){\n  // gl_FragColor = vec4(\n  //   snoise2(gl_FragCoord.xy),\n  //   snoise2(gl_FragCoord.yx),\n  //   snoise2(gl_FragCoord.xy * gl_FragCoord.yx),\n  //   0.0\n  // ) * 1.0;\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 0.0) * 1.0;\n}\n"},function(n,e){n.exports="#define GLSLIFY 1\nattribute vec3 position;\n\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n}\n"},function(n,e){n.exports="precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\nuniform sampler2D posTexture;\n\nuniform float time;\nuniform float delta;\nuniform float seperationDistance;\nuniform float alignmentDistance;\nuniform float cohesionDistance;\nuniform float numInstances;\nuniform vec3 eyeDir;\n\nconst float SPEED_LIMIT = 10.0;\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_4_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_4_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_4_1(vec4 x) {\n     return mod289_4_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_4_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_4_3(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_4_4 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_4_5 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_4_5;\n  vec3 i1 = min( g_4_5.xyz, l.zxy );\n  vec3 i2 = max( g_4_5.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_4_4.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_4_0(i);\n  vec4 p = permute_4_1( permute_4_1( permute_4_1(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_4_4.wyz - D_4_4.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_4_6 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_4_7 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_4_6.xy,h.z);\n  vec3 p3 = vec3(a1_4_6.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_4_2(vec4(dot(p0_4_7,p0_4_7), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_4_7 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_4_7,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nvec3 snoiseVec3_3_8( vec3 x ){\n\n  float s  = snoise_4_3(vec3( x ));\n  float s1 = snoise_4_3(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise_4_3(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n\n}\n\n\nvec3 curlNoise_3_9( vec3 p ){\n  \n  const float e = .1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3_3_8( p - dx );\n  vec3 p_x1 = snoiseVec3_3_8( p + dx );\n  vec3 p_y0 = snoiseVec3_3_8( p - dy );\n  vec3 p_y1 = snoiseVec3_3_8( p + dy );\n  vec3 p_z0 = snoiseVec3_3_8( p - dz );\n  vec3 p_z1 = snoiseVec3_3_8( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n\n}\n\n\n\nvec3 rotateVec3_1_10(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n    a.x * a.x * r + c,\n    a.y * a.x * r + a.z * s,\n    a.z * a.x * r - a.y * s,\n    a.x * a.y * r - a.z * s,\n    a.y * a.y * r + c,\n    a.z * a.y * r + a.x * s,\n    a.x * a.z * r + a.y * s,\n    a.y * a.z * r - a.x * s,\n    a.z * a.z * r + c\n  );\n  return m * p;\n}\n\n\nconst float PI_2_11 = 3.1415926535897932384626433832795;\n\n\nconst float PI_2 = PI_2_11 * 2.0;\n\nvoid main(){\n  float zoneRadius = seperationDistance + alignmentDistance + cohesionDistance;\n  float separationThresh = seperationDistance / zoneRadius;\n  float alignmentThresh = (seperationDistance + alignmentDistance) / zoneRadius;\n  float zoneRadiusSquared = zoneRadius * zoneRadius;\n\n  // vec3 predator = vec3(sin(time) * 100.0, 0.0, cos(time) * 100.0);\n  vec3 predator = vec3(0.0);\n\n  float instanceIndex = gl_FragCoord.y * resolution.x + gl_FragCoord.x;\n\n  // if(instanceIndex >= numInstances) {\n  //   discard;\n  // }\n\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec3 velocity = texture2D(texture, uv).xyz;\n  vec3 pos = texture2D(posTexture, uv).xyz;\n\n  float seperationSquared = seperationDistance * seperationDistance;\n  float cohesionSquared = cohesionDistance * cohesionDistance;\n\n  float limit = SPEED_LIMIT;\n\n  vec3 dir = predator - velocity;\n  float dist = length(dir);\n  float distSquared = dist * dist;\n\n  float preyRadius = 200.0;\n  float preyRadiusSq = preyRadius * preyRadius;\n\n  float f;\n\n  // move away from predator\n  if (dist < preyRadius) {\n    f = (distSquared / preyRadiusSq - 1.0) * delta * 300.0;\n    velocity += normalize(dir) * f;\n    limit += 5.0;\n  }\n\n  // Attract flocks\n  float attractD = 350.0 + sin(time * 1000.0 / 180.0 * PI_2_11) * 100.0;\n  vec3 attractor = normalize(rotateVec3_1_10(eyeDir, PI_2_11, vec3(0.0, 1.0, 0.0))) * attractD;\n  dir = pos - attractor;\n  velocity -= normalize(dir) * delta * 100.0;\n\n  // noise\n  velocity += curlNoise_3_9(normalize(pos) * 4.0) * 3.0;\n\n\n  const float width = resolution.x;\n  const float height = resolution.y;\n\n  float percent;\n  vec2 anotherUv;\n  vec3 anotherPos, anotherVelocity;\n  float threshDelta;\n  float adjustedPercent;\n  float anotherIndex;\n\n  for(float y = 0.0; y < height; y++) {\n    for(float x = 0.0; x < width; x++) {\n\n      anotherIndex = resolution.x * y + x;\n      if (anotherIndex >= numInstances) break;\n\n      anotherUv = vec2(x + 0.5, y + 0.5) / resolution.xy;\n      anotherPos = texture2D(posTexture, anotherUv).xyz;\n\n      dir = anotherPos - pos;\n      dist = length(dir);\n\n      if (dist < 0.0001) continue;\n\n      distSquared = dist * dist;\n\n      if (distSquared > zoneRadiusSquared) continue;\n\n      percent = distSquared / zoneRadiusSquared;\n\n      if (percent < separationThresh) { // low\n\n        // Separation - Move apart for comfort\n        f = (separationThresh / percent - 1.0) * delta;\n        velocity -= normalize(dir) * f;\n\n      } else if (percent < alignmentThresh) { // high\n\n        // Alignment - fly the same direction\n        threshDelta = alignmentThresh - separationThresh;\n        adjustedPercent = (percent - separationThresh) / threshDelta;\n\n        anotherVelocity = texture2D(texture, anotherUv).xyz;\n\n        f = (0.5 - cos(adjustedPercent * PI_2) * 0.5 + 0.5) * delta;\n        velocity += normalize(anotherVelocity) * f;\n\n      } else {\n\n        // Attraction / Cohesion - move closer\n        threshDelta = 1.0 - alignmentThresh;\n        adjustedPercent = (percent - alignmentThresh) / threshDelta;\n\n        f = (0.5 - (cos(adjustedPercent * PI_2) * -0.5 + 0.5 )) * delta;\n\n        velocity += normalize(dir) * f;\n      }\n    }\n  }\n\n  // Speed Limits\n  if (length(velocity) > limit) {\n    velocity = normalize(velocity) * limit;\n  }\n\n  gl_FragColor = vec4(velocity, 1.0);\n}\n";
},function(n,e){n.exports="precision highp float;\n#define GLSLIFY 1\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_1_0(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_1_1(vec3 x) {\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_1_2(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_1_0(i); // Avoid truncation effects in permutation\n  vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\n\nvoid main(){\n  gl_FragColor = vec4(\n    snoise_1_2(gl_FragCoord.xy),\n    snoise_1_2(gl_FragCoord.yx),\n    snoise_1_2(gl_FragCoord.xy * gl_FragCoord.yx),\n    0.0\n  ) * 200.0;\n}\n"},function(n,e){n.exports="precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\nuniform sampler2D velocityTexture;\nuniform float delta;\n\nvoid main(){\n  float instanceIndex = gl_FragCoord.y * resolution.x + gl_FragCoord.x;\n  vec2 tUV = gl_FragCoord.xy / resolution;\n  vec3 pos = texture2D(texture, tUV).xyz;\n\n  // 速度を加算\n  pos += texture2D(velocityTexture, tUV).xyz * delta * 10.0;\n\n  gl_FragColor = vec4(pos, 1.0);\n}\n"},function(n,e,t){var o,i,r=function(n,e){function t(){this.constructor=n}for(var o in e)a.call(e,o)&&(n[o]=e[o]);return t.prototype=e.prototype,n.prototype=new t,n.__super__=e.prototype,n},a={}.hasOwnProperty;i=t(29),o=function(n){function e(n){var o;this.imgPath=n,o=new THREE.PlaneBufferGeometry(20,16),this.geometry=new i(o,4),this.material=new THREE.RawShaderMaterial({uniforms:{time:{type:"1f",value:0},texture:{type:"t"},radius:{type:"1f",value:300}},vertexShader:t(49),fragmentShader:t(50),transparent:!0}),e.__super__.constructor.call(this,this.geometry,this.material),o.dispose()}return r(e,n),e.prototype.init=function(){var n,e,t;return n=.125*Math.PI,e=.67*Math.PI,t=Math.PI,this.geometry.addData("rotationY",[-n,n,-e,e],1),this.geometry.addData("rotationZ",[0,-t,0,-t],1),this.frustumCulled=!1,new Promise(function(n){return function(e){return(new THREE.TextureLoader).load(n.imgPath,function(t){return t.flipY=!1,t.needUpdate=!0,n.material.uniforms.texture.value=t,e()})}}(this))},e.prototype.update=function(){this.material.uniforms.time.value+=.001},e}(THREE.Mesh),n.exports=o},function(n,e){n.exports="#define GLSLIFY 1\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\nuniform float radius;\n\nattribute vec3 position;\nattribute vec2 uv;\nattribute float rotationY;\nattribute float rotationZ;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvec3 rotateVec3_1_0(vec3 p, float angle, vec3 axis){\n  vec3 a = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float r = 1.0 - c;\n  mat3 m = mat3(\n    a.x * a.x * r + c,\n    a.y * a.x * r + a.z * s,\n    a.z * a.x * r - a.y * s,\n    a.x * a.y * r - a.z * s,\n    a.y * a.y * r + c,\n    a.z * a.y * r + a.x * s,\n    a.x * a.z * r + a.y * s,\n    a.y * a.z * r - a.x * s,\n    a.z * a.z * r + c\n  );\n  return m * p;\n}\n\n\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat sineOut_2_1(float t) {\n  return sin(t * HALF_PI);\n}\n\n\n\n\nvoid main() {\n  vec3 pos = position;\n\n  pos.x += sineOut_2_1(mod(time, 0.03) / 0.03) * 5.0;\n  pos = rotateVec3_1_0(pos, rotationZ, vec3(0.0, 0.0, 1.0));\n  pos.z = -radius;\n  pos = rotateVec3_1_0(pos, rotationY, vec3(0.0, 1.0, 0.0));\n\n  vColor = vec4(1.0, 0.6, 0.0, 0.4);\n  vUv = uv;\n\n  // position\n  vec4 modelPos = modelMatrix * vec4(pos, 1.0);\n  vec4 modelViewPos = viewMatrix * modelPos;\n  gl_Position = projectionMatrix * modelViewPos;\n}\n"},function(n,e){n.exports="precision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nuniform sampler2D texture;\n\nvoid main(){\n  vec4 color = vColor * texture2D(texture, vUv);\n  if(color.a == 0.0) {\n    discard;\n  } else {\n    gl_FragColor = color;\n  }\n}\n"}]);